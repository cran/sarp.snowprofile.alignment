<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Technical details</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Technical details</h1>



<div id="snow-profile-alignment-and-similarity-assessment-for-aggregating-clustering-and-evaluating-of-snowpack-model-output-for-avalanche-forecasting" class="section level2">
<h2>Snow profile alignment and similarity assessment for aggregating, clustering, and evaluating of snowpack model output for avalanche forecasting</h2>
<p>This vignette creates a detailed link between the methods described in the paper</p>
<pre><code>Herla, F., Horton, S., Mair, P., &amp; Haegeli, P. (in review). Snow profile alignment and similarity assessment for aggregating, clustering, and evaluating of snowpack model output for avalanche forecasting.</code></pre>
<p>and this companion R package. While the basic workflow and the use of the high-level functions are described in the vignette <strong>Basic workflow</strong>, this vignette describes how the (default) workflow of the package can be altered and the how the methods could be improved.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">library</span>(sarp.snowprofile.alignment)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">#&gt; Loading required package: sarp.snowprofile</span></a></code></pre></div>
</div>
<div id="aligning-snow-profiles-based-on-dynamic-time-warping-dtw" class="section level2">
<h2>1. Aligning snow profiles based on Dynamic Time Warping (DTW)</h2>
<p>The individual steps of aligning snow profiles—taken from the documentation of the core function <code>dtwSP</code>:</p>
<ol style="list-style-type: decimal">
<li>(optional) <strong>Rescale</strong> the profiles to the same height (cf., <code>scaleSnowHeight</code>)</li>
<li><strong>Resample</strong> the profiles onto the same depth grid. 2 different approaches:
<ul>
<li>regular grid with a sampling rate that is provided by the user (recommended, cf., <code>resampleSP</code>).<br />
This approach requires to rescale the profiles.</li>
<li>irregular grid that includes all layer interfaces within the two profiles (i.e., set <code>resamplingRate = NA</code>) (cf., <code>resampleSPpairs</code>)</li>
</ul></li>
<li>Compute a weighted <strong>local cost matrix</strong> from multiple layer characteristics (cf., <code>distMatSP</code>)</li>
<li><strong>Match the layers</strong> of the profiles with a call to <code>dtw</code> (eponymous R package)</li>
<li>Align the profiles by <strong>warping</strong> the query profile onto the reference profile (cf., <code>warpSP</code>)</li>
<li>(optional) If the function has been called with multiple different boundary conditions (global, top-down, or bottom-up alignments), the optimal alignment as determined by <code>simSP</code> will be returned.</li>
</ol>
<div id="preprocessing-of-the-profiles-prior-to-the-alignment" class="section level3">
<h3>1.1 Preprocessing of the profiles prior to the alignment</h3>
<p>A series of functions exist that manipulate the snow profiles prior to the alignment or the similarity assessment. All these manipulations happen by default, and can be controlled in the arguments to <code>dtwSP</code>.<br />
<strong>Rescaling and resampling</strong></p>
<ul>
<li><code>scaleSnowHeight</code>: Scale the total snow height of a profile with a uniform scaling factor (commonly determined from the height of a second profile)</li>
<li><code>resampleSP</code>: Resample an individual profile</li>
<li><code>reScaleSampleSPx</code>: Both rescale and resample a set of profiles to identical snow heights and onto a regular grid</li>
</ul>
<p><strong>Reducing the number of layers</strong></p>
<ul>
<li><code>mergeIdentLayers</code>: Merge adjacent layers that have identical properties</li>
<li><code>rmZeroThicknessLayers</code>: Remove or reset layers of zero thickness (i.e., these layers originate from warping one profile onto another)</li>
</ul>
</div>
<div id="computing-a-weighted-local-cost-matrix-from-multiple-layer-characteristics" class="section level3">
<h3>1.2 Computing a weighted local cost matrix from multiple layer characteristics</h3>
<p>Computing a local cost matrix is fundamental to DTW alignments and is carried out in <code>distMatSP</code>.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Assessing the differences of individual snow layers</strong> Currently, distance functions are implemented for the layer characteristics <em>grain type, hardness, and deposition date</em>. The distance function for categorical grain types relies on a matrix that stores the distances between different categories. Since the similarity requirements are slighlty different for aligning profiles versus assessing their similarity, two matrices are implemented:</p>
<ul>
<li><code>grainSimilarity_align</code> (Table 1A in the paper)</li>
<li><code>grainSimilarity_evaluate</code> (Table 1B in the paper)</li>
<li><code>swissSimilarityMatrix</code> (grain type similarity matrix defined by Lehning et al, 2001)</li>
</ul></li>
<li><p><strong>Computing a local cost matrix</strong><br />
First, a distance matrix is computed for each included layer characteristic that stores the distances between individual layer combinations. Then these distance matrices are combined into one resulting distance matrix (i.e., local cost matrix) by weighted averaging. Optionally, a preferential layer matching manipulation can be included into the local cost matrix.</p></li>
</ol>
<p>In <code>distMatSP</code> all parameters related to the local cost matrix can be controlled, e.g.</p>
<ul>
<li>Layer characteristics to include</li>
<li>Relative averaging weights of the layer characteristics</li>
<li>Grain type similarity matrix</li>
<li>Warping window function</li>
<li>Preferential layer matching (defined by the coefficients in Table 2 in the paper: <code>layerWeightingMat</code>)—currently, implemented solely based on grain type information.</li>
</ul>
</div>
<div id="obtaining-the-optimal-alignment-of-the-snow-profiles" class="section level3">
<h3>1.3 Obtaining the optimal alignment of the snow profiles</h3>
<p>Obtaining the optimal alignment of pairs of snow profiles is the core task of this package. All functions and controls from the sections 1.1 and 1.2 above can be modified in the call to the core function <code>dtwSP</code>. Additional controls are, e.g.</p>
<ul>
<li>local slope constraint</li>
<li>boundary conditions: global alignment vs. partial alignment</li>
</ul>
<p>Partial alignments (i.e., <code>open.end</code>) can be started from the snow surface downwards (<code>top.down</code>) or from the ground upwards (<code>bottom.up</code>). When the function is called to align the profiles with <em>multiple different boundary conditions (global, top-down, bottom-up), the alignment that yields the highest similarity is returned</em>.</p>
<p>While DTW computes the matching between the layers, the actual alignment is carried out with a warping function <code>warpSP</code>. Since that warping is different for bottom-up and top-down alignments, and it is different for the two profiles, <code>warpSP</code> provides solutions for most combinations.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
